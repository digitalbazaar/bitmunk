<html>
   <head>
      <style> 
      canvas {
        background: black;
      }
      </style>
      <script type="text/javascript" src="/bitmunk/js/swfobject/swfobject.js"></script>
      <script type="text/javascript" src="/bitmunk/js/jquery.js"></script>
      <script type="text/javascript" src="/bitmunk/test/jscrypto/jscrypto.js"></script>
      <script type="text/javascript" src="/bitmunk/test/sjcl/sjcl.js"></script>
      <script type="text/javascript" src="/bitmunk/test/sjcl/aes.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/random.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/util.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/md5.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/sha1.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/aes.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/tls.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/string_extend.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/pidcrypt.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/pidcrypt_util.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/prng4.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/rng.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/md5.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/aes_core.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/aes_cbc.js"></script>
      
      <script type="text/javascript">

      // load flash tester
      swfobject.embedSWF(
         "/bitmunk/test/Test.swf", "flashTest", "0", "0", "9.0.0",
         "/bitmunk/js/swfobject/expressInstall.swf",
         {}, {allowscriptaccess: 'always'}, {});

      // set krypto alias
      var krypto = window.krypto;

      var canvas_clear = function()
      {
         var canvas = document.getElementById("canvas");
         var ctx = canvas.getContext("2d");
         ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      var random_krypto = function()
      {
         do_random(krypto.random);
      };

      var random_pidcrypt = function()
      {
         do_random(
         {
            getBytes: function(count)
            {
               var ba = [];
               ba[count - 1] = 0;
               var sr = new SecureRandom();
               sr.nextBytes(ba);
               var b = '';
               for(var i = 0; i < count; i++)
               {
                  b += String.fromCharCode(ba[i]);
               }
               return b;
            }
         });
      };
      
      var do_random = function(inf)
      {
         console.log('painting canvas');
         var canvas = document.getElementById("canvas");
         var ctx = canvas.getContext("2d");
         var imgData = ctx.createImageData(canvas.width, canvas.height);

         // generate random bytes
         var bytes = inf.getBytes(canvas.width * canvas.height * 3);
         var n = 0;
         for(var x = 0; x < imgData.width; x++)
         {
            for(var y = 0; y < imgData.height; y++)
            {
               // index of the pixel in the array
               var idx = (x + y * imgData.width) * 4;

               // set values
               imgData.data[idx + 0] = bytes.charCodeAt(n++); // Red
               imgData.data[idx + 1] = bytes.charCodeAt(n++); // Green
               imgData.data[idx + 2] = bytes.charCodeAt(n++); // Blue
               imgData.data[idx + 3] = 255;        // Alpha
            }
         }

         ctx.putImageData(imgData, 0, 0);
         console.log('done');
      };

      var test_buffer = function()
      {
         ba = krypto.util.createBuffer();
         ba.putByte(1);
         ba.putByte(2);
         ba.putByte(3);
         ba.putByte(4);
         ba.putInt32(4);
         ba.putByte(1);
         ba.putByte(2);
         ba.putByte(3);
         ba.putInt32(4294967295);
         var hex = ba.toHex();
         var bytes = [];
         while(ba.length() > 0)
         {
            bytes.push(ba.getByte());
         }
         var expect = [1, 2, 3, 4, 0, 0, 0, 4, 1, 2, 3, 255, 255, 255, 255];
         var exHex = '0102030400000004010203ffffffff';
         console.log('ba', bytes);
         console.log('ex', expect);
         console.log('assert', hex === exHex);
      };

      var test_base64 = function()
      {
         var s1 = '00010203050607080A0B0C0D0F1011121415161719';
         var s2 = 'MDAwMTAyMDMwNTA2MDcwODBBMEIwQzBEMEYxMDExMTIxNDE1MTYxNzE5';
         var out = krypto.util.encode64(s1);
         console.log('out', out);
         console.log('ex', s2);
         out = krypto.util.decode64(s2);
         console.log('out', out);
         console.log('ex', s1);
      };

      var test_base64_speed = function()
      {
         var str, count, st, et;

         str = '';
         for(var i = 0; i < 100; i++)
         {
            str += '00010203050607080A0B0C0D0F1011121415161719';
         }
         count = 5000;
         st = +new Date();
         for(var i = 0; i < count; i++)
         {
            var out = krypto.util.encode64(str);
         }
         et = +new Date();
         console.log('time per encode', ((et - st)/count) + ' ms');

         str = '';
         for(var i = 0; i < 100; i++)
         {
            str += 'MDAwMTAyMDMwNTA2MDcwODBBMEIwQzBEMEYxMDExMTIxNDE1MTYxNzE5';
         }
         count = 5000;
         st = +new Date();
         for(var i = 0; i < count; i++)
         {
            var out = krypto.util.decode64(str);
         }
         et = +new Date();
         console.log('time per decode', ((et - st)/count) + ' ms');
      };

      var test_md5 = function()
      {
         // empty message sha-1
         var expect = 'd41d8cd98f00b204e9800998ecf8427e';
         var md = krypto.md.md5.create();
         console.log('digest', md.digest().toHex());
         console.log('assert', md.digest().toHex() === expect);

         // message md5 ('abc')
         expect = '900150983cd24fb0d6963f7d28e17f72';
         md.reset();
         md.update('abc');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);

         // message md5 ('The quick brown fox jumps over the lazy dog')
         expect = '9e107d9d372bb6826bd81d3542a419d6';
         md.reset();
         md.update('The quick brown fox jumps over the lazy dog');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
         
         // message md5 ('THIS IS A MESSAGE')
         expect = '78eebfd9d42958e3f31244f116ab7bbe';
         md.reset();
         md.update('THIS IS ');
         md.update('A MESSAGE');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
      };

      var count_md5_speed = 300;
      var test_md5_speed = function()
      {
         // create input data
         var input = ['0123456789abcdef', '', '', '', ''];
         for(var i = 0; i < 4; ++i)
         {
            input[1] += input[0];
         }
         for(var i = 0; i < 4; ++i)
         {
            input[2] += input[1];
         }
         for(var i = 0; i < 4; ++i)
         {
            input[3] += input[2];
         }
         for(var i = 0; i < 8; ++i)
         {
            input[4] += input[3];
         }
         
         var md = krypto.md.md5.create();

         console.log('md5 times in 1000s of bytes/sec processed:');

         var st, et;
         var output =
            ['  16 bytes: ',
             '  64 bytes: ',
             ' 256 bytes: ',
             '1024 bytes: ',
             '8192 bytes: '];
         var s = [16, 64, 256, 1024, 8192];
         var t = [0, 0, 0, 0, 0];
         var ct = count_md5_speed;
         var c = [ct, ct, ct, ct, ct];
         for(var n = 0; n < 5; ++n)
         {
            var f = function(n)
            {
               setTimeout(function()
               {
                  for(var i = 0; i < c[n]; ++i)
                  {
                     st = +new Date();
                     md.update(input[n]);
                     md.digest();
                     et = +new Date();
                     t[n] = t[n] + (et - st);
                     md.reset();
                  }
                  console.log(output[n], (t[n] / c[n] * s[n]) + 'k/sec');
               }, 0);
            }(n);
         }
      };
      
      var test_sha1 = function()
      {
         // empty message sha-1
         var expect = 'da39a3ee5e6b4b0d3255bfef95601890afd80709';
         var md = krypto.md.sha1.create();
         //console.log('digest', md.digest().toHex());
         console.log('assert', md.digest().toHex() === expect);

         // message sha-1 ('abc')
         expect = 'a9993e364706816aba3e25717850c26c9cd0d89d';
         md.reset();
         md.update('abc');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
         
         // message sha-1 ('The quick brown fox jumps over the lazy dog')
         expect = '2fd4e1c67a2d28fced849ee1bb76e7391b93eb12';
         md.reset();
         md.update('The quick brown fox jumps over the lazy dog');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
         
         // message sha-1 ('THIS IS A MESSAGE')
         expect = '5f24f4d6499fd2d44df6c6e94be8b14a796c071d';
         md.reset();
         md.update('THIS IS ');
         md.update('A MESSAGE');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
      };

      var count_sha1_speed = 300;
      var test_sha1_speed = function()
      {
         // create input data
         var input = ['0123456789abcdef', '', '', '', ''];
         for(var i = 0; i < 4; ++i)
         {
            input[1] += input[0];
         }
         for(var i = 0; i < 4; ++i)
         {
            input[2] += input[1];
         }
         for(var i = 0; i < 4; ++i)
         {
            input[3] += input[2];
         }
         for(var i = 0; i < 8; ++i)
         {
            input[4] += input[3];
         }
         
         var md = krypto.md.sha1.create();

         console.log('sha-1 times in 1000s of bytes/sec processed:');

         var st, et;
         var output =
            ['  16 bytes: ',
             '  64 bytes: ',
             ' 256 bytes: ',
             '1024 bytes: ',
             '8192 bytes: '];
         var s = [16, 64, 256, 1024, 8192];
         var t = [0, 0, 0, 0, 0];
         var ct = count_sha1_speed;
         var c = [ct, ct, ct, ct, ct];
         for(var n = 0; n < 5; ++n)
         {
            var f = function(n)
            {
               setTimeout(function()
               {
                  for(var i = 0; i < c[n]; ++i)
                  {
                     st = +new Date();
                     md.update(input[n]);
                     md.digest();
                     et = +new Date();
                     t[n] = t[n] + (et - st);
                     md.reset();
                  }
                  console.log(output[n], (t[n] / c[n] * s[n]) + 'k/sec');
               }, 0);
            }(n);
         }
      };

      // 128-bit test keys
      var aesKeys = [
         '00010203050607080A0B0C0D0F101112',
         '14151617191A1B1C1E1F202123242526',
         '28292A2B2D2E2F30323334353738393A',
         '3C3D3E3F41424344464748494B4C4D4E',
         '50515253555657585A5B5C5D5F606162',
         '64656667696A6B6C6E6F707173747576',
         '78797A7B7D7E7F80828384858788898A',
         '8C8D8E8F91929394969798999B9C9D9E',
         'A0A1A2A3A5A6A7A8AAABACADAFB0B1B2',
         'B4B5B6B7B9BABBBCBEBFC0C1C3C4C5C6',
         'C8C9CACBCDCECFD0D2D3D4D5D7D8D9DA',
         'DCDDDEDFE1E2E3E4E6E7E8E9EBECEDEE',
         'F0F1F2F3F5F6F7F8FAFBFCFDFE010002',
         '04050607090A0B0C0E0F101113141516',
         '2C2D2E2F31323334363738393B3C3D3E',
         '40414243454647484A4B4C4D4F505152',
         '54555657595A5B5C5E5F606163646566',
         '68696A6B6D6E6F70727374757778797A',
         '7C7D7E7F81828384868788898B8C8D8E',
         'A4A5A6A7A9AAABACAEAFB0B1B3B4B5B6'];

      // create aes IV
      var aesIvBytes = krypto.random.getBytes(16);
      var aesIvWords = [];
      var aesIv = '';
      for(var i = 0; i < aesIvBytes.length; i++)
      {
         var hex = aesIvBytes.charCodeAt(i).toString(16);
         aesIv += (hex.length == 1) ? ('0' + hex) : hex;
      }
      for(var i = 0; i < aesIvBytes.length; i += 4)
      {
         aesIvWords.push(
            aesIvBytes.charCodeAt(i) << 24 ^
            aesIvBytes.charCodeAt(i + 1) << 16 ^
            aesIvBytes.charCodeAt(i + 2) << 8 ^
            aesIvBytes.charCodeAt(i + 3));
      }
      //console.log('aesIv', aesIv);

      // test data to encrypt
      var aesPlain =
         String.fromCharCode(0x00) +
         String.fromCharCode(0x11) +
         String.fromCharCode(0x22) +
         String.fromCharCode(0x33) +
         String.fromCharCode(0x44) +
         String.fromCharCode(0x55) +
         String.fromCharCode(0x66) +
         String.fromCharCode(0x77) +
         String.fromCharCode(0x88) +
         String.fromCharCode(0x99) +
         String.fromCharCode(0xaa) +
         String.fromCharCode(0xbb) +
         String.fromCharCode(0xcc) +
         String.fromCharCode(0xdd) +
         String.fromCharCode(0xee) +
         String.fromCharCode(0xff);
      var aesPlainWords = [
         0x00112233,
         0x44556677,
         0x8899aabb,
         0xccddeeff];
      var aesPlainBytes = [
         0x00, 0x11, 0x22, 0x33,
         0x44, 0x55, 0x66, 0x77,
         0x88, 0x99, 0xaa, 0xbb,
         0xcc, 0xdd, 0xee, 0xff];

      var aes_test_tables = function()
      {
         console.log('generating AES test tables ...');

         var xtime = new Array(256);
         for(var i = 0; i < 128; i++)
         {
            xtime[i] = i << 1;
            xtime[i + 128] = (i + 128) << 1 ^ 0x11B;
         }
         console.log('first xtime', xtime);   

         // compute xtime table which maps b onto GF(b, 0x02)
         // compute anti-log and log tables
         var xtime = new Array(256);
         var atable = new Array(256);
         var ltable = new Array(256);
         var b = 1, b2;
         for(var i = 0; i < 256; i++)
         {
            atable[i] = b;
            ltable[b] = i;
            b2 = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1 & 0xFF);
            xtime[b] = b2;
            b ^= b2;
         }
         xtime[0] = 0;
         atable[255] = atable[0];
         ltable[0] = 0;

         // compute sbox and isbox
         var sbox = new Array(256);
         var isbox = new Array(256);
         for(var i = 0; i < 256; i++)
         {
            // multiplicative inverse: 0 or atable[255 - ltable[i]]
            b = (i == 0) ? 0 : atable[255 - ltable[i]];

            // SubBytes() affine transformation 
            b = b ^ (b << 1) ^ (b << 2) ^ (b << 3) ^ (b << 4);
            b = (b >> 8) ^ (b & 0xFF) ^ 0x63;
            sbox[i] = b;
            isbox[b] = i;
         }
         
         var inv = [];
         for(var i = 0; i < 256; i++)
         {
            inv[i] = (i == 0) ? 0 : atable[(255 - ltable[i])];
         }
         console.log('inv', inv);

         // inverse: atable[255 - ltable[b]];
         console.log('atable', atable);
         console.log('ltable', ltable);
         console.log('xtime', xtime);

         console.log('xtime(61)=' + xtime[61] + ',gmul=' +
               atable[(ltable[61] + ltable[2])%255]);
         console.log('sbox', sbox);
         console.log('isbox', isbox);
      };

      var word_array_to_string = function(wa)
      {
         // get words from buffer
         if(wa.constructor != Array)
         {
            var bytes = wa.bytes();
            wa = [];
            for(var i = 0; i < bytes.length; i += 4)
            {
               wa.push(
                  bytes.charCodeAt(i) << 24 ^
                  bytes.charCodeAt(i + 1) << 16 ^
                  bytes.charCodeAt(i + 2) << 8 ^
                  bytes.charCodeAt(i + 3));
            }
         }
         
         var str = '[';
         for(var i = 0; i < wa.length; i++)
         {
            // handle signed hex
            if(wa[i] < 0)
            {
               str += (wa[i] + 0xFFFFFFFF + 1).toString(16);
            }
            else
            {
               str += wa[i].toString(16);
            }
            if(i + 1 < wa.length)
            {
               str += ',';
            }
         }
         str += ']';
         return str;
      };

      var aes_krypto_128 = function()
      {
         console.log('testing krypto AES-128 ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         var plain = block;
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         
         var expect = [];
         expect.push(0x69c4e0d8);
         expect.push(0x6a7b0430);
         expect.push(0xd8cdb780);
         expect.push(0x70b4c55a);

         var output = [];
         var w = krypto.aes._expandKey(key, false);
         krypto.aes._updateBlock(w, block, output, false);
         console.log('ciphered', word_array_to_string(output));
         console.log('expect', word_array_to_string(expect));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(expect));

         block = output;
         output = [];
         w = krypto.aes._expandKey(key, true);
         krypto.aes._updateBlock(w, block, output, true);
         console.log('plain', word_array_to_string(output));
         console.log('expect', word_array_to_string(plain));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(plain));
      };

      var aes_krypto_192 = function()
      {
         console.log('testing krypto AES-192 ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         var plain = block;
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         key.push(0x10111213);
         key.push(0x14151617);
         
         var expect = [];
         expect.push(0xdda97ca4);
         expect.push(0x864cdfe0);
         expect.push(0x6eaf70a0);
         expect.push(0xec0d7191);

         var output = [];
         var w = krypto.aes._expandKey(key, false);
         krypto.aes._updateBlock(w, block, output, false);
         console.log('ciphered', word_array_to_string(output));
         console.log('expect', word_array_to_string(expect));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(expect));

         block = output;
         output = [];
         w = krypto.aes._expandKey(key, true);
         krypto.aes._updateBlock(w, block, output, true);
         console.log('plain', word_array_to_string(output));
         console.log('expect', word_array_to_string(plain));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(plain));
      };

      var aes_krypto_256 = function()
      {
         console.log('testing krypto AES-256 ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         var plain = block;
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         key.push(0x10111213);
         key.push(0x14151617);
         key.push(0x18191a1b);
         key.push(0x1c1d1e1f);
         
         var expect = [];
         expect.push(0x8ea2b7ca);
         expect.push(0x516745bf);
         expect.push(0xeafc4990);
         expect.push(0x4b496089);

         var output = [];
         var w = krypto.aes._expandKey(key, false);
         krypto.aes._updateBlock(w, block, output, false);
         console.log('ciphered', word_array_to_string(output));
         console.log('expect', word_array_to_string(expect));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(expect));

         block = output;
         output = [];
         w = krypto.aes._expandKey(key, true);
         krypto.aes._updateBlock(w, block, output, true);
         console.log('plain', word_array_to_string(output));
         console.log('expect', word_array_to_string(plain));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(plain));
      };

      var count_128_speed = 70000;

      var aes_krypto_128_speed = function()
      {
         console.log('testing krypto AES-128 speed ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = count_128_speed;
         for(var i = 0; i < count; i++)
         {
            var output = [];
            var w = krypto.aes._expandKey(key, false);
            now = +new Date();
            krypto.aes._updateBlock(w, block, output, false);
            totalEncrypt += (+new Date()) - now;

            block = output;
            output = [];
            w = krypto.aes._expandKey(key, true);
            now = +new Date();
            krypto.aes._updateBlock(w, block, output, true);
            totalDecrypt += (+new Date()) - now;
         }

         console.log('encrypt time: ' + (totalEncrypt / count) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / count) + ' ms');
         console.log('krypto aes-128 speed test complete.');
      };

      var aes_krypto = function()
      {
         console.log('testing AES (krypto) ...');

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = 100;
         var totalTimes = aesKeys.length * count;
         for(var n = 0; n < count; n++)
         {
            for(var i = 0; i < aesKeys.length; i++)
            {
               var k = aesKeys[i];
               var key = [];
               key.push(parseInt(k.substr(0, 8), 16));
               key.push(parseInt(k.substr(8, 8), 16));
               key.push(parseInt(k.substr(16, 8), 16));
               key.push(parseInt(k.substr(24, 8), 16));
               
               var we = krypto.aes._expandKey(key, false);
               var wd = krypto.aes._expandKey(key, true);
               var block = aesPlainWords;
               var output = [];
               
               // encrypt
               now = +new Date();
               krypto.aes._updateBlock(we, block, output, false);
               totalEncrypt += (+new Date()) - now;
               
               // decrypt
               block = output;
               output = [];
               now = +new Date();
               krypto.aes._updateBlock(wd, block, output, true);
               totalDecrypt += (+new Date()) - now;
            }
         }
         
         console.log('encrypt time: ' + (totalEncrypt / totalTimes) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / totalTimes) + ' ms');
         console.log('krypto aes test complete.');
      };

      var aes_krypto_cbc = function()
      {
         console.log('testing AES-CBC (krypto) ...');

         for(var i = 0; i < aesKeys.length; i++)
         {
            var k = aesKeys[i];
            var key = [];
            key.push(parseInt(k.substr(0, 8), 16));
            key.push(parseInt(k.substr(8, 8), 16));
            key.push(parseInt(k.substr(16, 8), 16));
            key.push(parseInt(k.substr(24, 8), 16));
            
            var input = krypto.util.createBuffer(aesPlain);
            
            // encrypt
            cipher = krypto.aes.createEncryptionCipher(key);
            cipher.start(aesIvWords);
            cipher.update(input);
            cipher.finish();
            
            // decrypt
            var ct = cipher.output;
            cipher = krypto.aes.createDecryptionCipher(key);
            cipher.start(aesIvWords);
            cipher.update(ct);
            cipher.finish();
            
            console.log('plain', word_array_to_string(cipher.output));
            console.log('expect', word_array_to_string(aesPlainWords));
            console.log('assert',
               word_array_to_string(cipher.output) ==
               word_array_to_string(aesPlainWords));
         }
      };

      var aes_krypto_cbc_speed = function()
      {
         console.log('testing AES-CBC (krypto) ...');

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = 2000;
         var totalTimes = aesKeys.length * count;
         for(var n = 0; n < count; n++)
         {
            for(var i = 0; i < aesKeys.length; i++)
            {
               var k = aesKeys[i];
               var key = [];
               key.push(parseInt(k.substr(0, 8), 16));
               key.push(parseInt(k.substr(8, 8), 16));
               key.push(parseInt(k.substr(16, 8), 16));
               key.push(parseInt(k.substr(24, 8), 16));
               
               var input = krypto.util.createBuffer(aesPlain);
               
               // encrypt
               cipher = krypto.aes.startEncrypting(key, aesIvWords);
               now = +new Date();
               cipher.update(input);
               cipher.finish();
               totalEncrypt += (+new Date()) - now;
               
               // decrypt
               var ct = cipher.output;
               cipher = krypto.aes.startDecrypting(key, aesIvWords);
               now = +new Date();
               cipher.update(ct);
               cipher.finish();
               totalDecrypt += (+new Date()) - now;
            }
         }

         console.log('encrypt time: ' + (totalEncrypt / totalTimes) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / totalTimes) + ' ms');
         console.log('krypto aes test complete.');
      };

      var aes_jscrypto_128_speed = function()
      {
         console.log('testing AES (jscrypto) speed ...');

         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = count_128_speed;
         for(var i = 0; i < count; i++)
         {
            var cipher = new aes(key);
            var output = [];
            now = +new Date();
            cipher.encryptBlock(block, output, false);
            totalEncrypt += (+new Date()) - now;

            block = output;
            output = [];
            now = +new Date();
            cipher.decryptBlock(block, output);
            totalDecrypt += (+new Date()) - now;
         }

         console.log('encrypt time: ' + (totalEncrypt / count) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / count) + ' ms');
         console.log('jscrypto aes-128 speed test complete.');
      };
      
      var aes_sjcl_128_speed = function()
      {
         console.log('testing AES (sjcl) speed ...');

         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = count_128_speed;
         for(var i = 0; i < count; i++)
         {
            var cipher = new sjcl.cipher.aes(key);
            var output;
            now = +new Date();
            output = cipher.encrypt(block);
            totalEncrypt += (+new Date()) - now;

            block = output;
            output = [];
            now = +new Date();
            output = cipher.decrypt(block);
            totalDecrypt += (+new Date()) - now;
         }

         console.log('encrypt time: ' + (totalEncrypt / count) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / count) + ' ms');
         console.log('sjcl aes-128 speed test complete.');
      };
      
      var aes_pid_crypt = function()
      {
         console.log('testing AES (pidcrypt) ...');

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         for(var i = 0; i < aesKeys.length; i++)
         {
            var cipher = new pidCrypt.AES.CBC();
            var key = aesKeys[i];
            var plainBytes = aesPlainBytes;

            // encrypt
            cipher.initByValues('', key, aesIv);
            now = +new Date();
            var cipherBytes = cipher.encryptRaw(plainBytes);
            totalEncrypt += (+new Date()) - now;
            
            // decrypt
            cipher.initByValues('', key, aesIv);
            now = +new Date();
            cipher.decryptRaw(cipherBytes);
            totalDecrypt += (+new Date()) - now;

            /* Base64-encoding used here
            // encrypt
            cipher.initByValues(aesPlain, key, aesIv);
            now = +new Date();
            var ciphered = cipher.encrypt();
            totalEncrypt += (+new Date()) - now;

            // decrypt
            cipher.initByValues(ciphered, key, aesIv);
            now = +new Date();
            cipher.decrypt();
            totalDecrypt += (+new Date()) - now;
            */
         }

         var len = aesKeys.length;
         console.log('encrypt time: ' + (totalEncrypt / len) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / len) + ' ms');
         console.log('pidcrypt aes test complete.');
      };

      var aes_as3crypto = function()
      {
         console.log('testing AES (as3crypto) ...');
         document.getElementById('flashTest').aes();
      };

      var aes_as3crypto_cbc = function()
      {
         console.log('testing AES-CBC (as3crypto) ...');
         document.getElementById('flashTest').aes_cbc();
      };

      var aes_flash_128 = function()
      {
         console.log('testing AES (flash 128) ...');
         document.getElementById('flashTest').aes_flash_128();
      };

      var aes_flash_test = function()
      {
         console.log('testing AES (flash) ...');
         document.getElementById('flashTest').aes_test();
      };

      var tls_handshake = function()
      {
         console.log('testing TLS handshake ...');

         // FIXME: implement calls to create each type of client message
         // FIXME: implement calls to parse each type of server message
         // FIXME: test those
         // FIXME: implement state changes

         // FIXME: get byte array stuff in order for data in tls records.
         // FIXME: need to be able to write a TLS vector into a byte array, etc.
         // FIXME: run regression tests for aes

         // FIXME: update socket pool in flash to be able to set conditional
         // event handlers ... ie: js sets a handler for when X number of
         // bytes are received so js only gets the event once that has happened
      };

      </script>
   </head>
   <body>
      <p>Use the controls below to test krypto stuff.</p>
      <div id="random_controls">
         <button id="clear" onclick="javascript:return canvas_clear();">clear</button>
         <button id="random1" onclick="javascript:return random_krypto();">krypto</button>
         <button id="random2" onclick="javascript:return random_pidcrypt();">pidcrypt</button>
      </div>
      <canvas id="canvas" width="300" height="300"></canvas>
      <div id="util_controls">
         <button id="buffer" onclick="javascript:return test_buffer();">buffer</button>
         <button id="base64" onclick="javascript:return test_base64();">base64</button>
         <button id="base64_speed" onclick="javascript:return test_base64_speed();">base64 speed</button>
      </div>
      <div id="hash_controls">
         <button id="md5" onclick="javascript:return test_md5();">md5</button>
         <button id="md5_speed" onclick="javascript:return test_md5_speed();">md5 speed</button>
         <button id="sha1" onclick="javascript:return test_sha1();">sha1</button>
         <button id="sha1_speed" onclick="javascript:return test_sha1_speed();">sha1 speed</button>
      </div>
      <div id="flashTest">
         <p>Could not load the flash Test.</p>
      </div>
      <div id="aes_controls">
         <button id="aes_krypto128" onclick="javascript:return aes_krypto_128();">krypto 128</button>
         <button id="aes_krypto192" onclick="javascript:return aes_krypto_192();">krypto 192</button>
         <button id="aes_krypto256" onclick="javascript:return aes_krypto_256();">krypto 256</button>
         <button id="aes__krypto128_speed" onclick="javascript:return aes_krypto_128_speed();">krypto 128 speed</button>
         <button id="aes__jscrypto128_speed" onclick="javascript:return aes_jscrypto_128_speed();">jscrypto 128 speed</button>
         <button id="aes__sjcl128_speed" onclick="javascript:return aes_sjcl_128_speed();">sjcl 128 speed</button>
         <br />
         <button id="aes_krypto" onclick="javascript:return aes_krypto();">krypto</button>
         <button id="aes_krypto_cbc" onclick="javascript:return aes_krypto_cbc();">krypto CBC</button>         <button id="aes6" onclick="javascript:return aes_krypto_cbc_speed();">krypto CBC speed</button>
         <button id="aes_pidcrypt" onclick="javascript:return aes_pid_crypt();">pidcrypt</button>
         <button id="aes_as3crypto" onclick="javascript:return aes_as3crypto();">as3crypto</button>
         <button id="aes_as3crypto_cbc" onclick="javascript:return aes_as3crypto_cbc();">as3crypto CBC</button>
         <button id="aes_flash128" onclick="javascript:return aes_flash_128();">flash 128</button>
         <button id="aes_flash" onclick="javascript:return aes_flash_test();">flash test</button>
         <br />
         <button id="tls_handshake" onclick="javascript:return tls_handshake();">tls handshake</button>
      </div>
   </body>
</html>
