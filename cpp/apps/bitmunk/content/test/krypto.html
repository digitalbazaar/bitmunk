<html>
   <head>
      <style> 
      canvas {
        background: black;
      }
      </style>
      <script type="text/javascript" src="/bitmunk/js/swfobject/swfobject.js"></script>
      <script type="text/javascript" src="/bitmunk/js/jquery.js"></script>
      <script type="text/javascript" src="/bitmunk/test/jscrypto/jscrypto.js"></script>
      <script type="text/javascript" src="/bitmunk/test/sjcl/sjcl.js"></script>
      <script type="text/javascript" src="/bitmunk/test/sjcl/aes.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/random.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/util.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/md5.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/sha1.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/hmac.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/aes.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/asn1.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/jsbn.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/jsbn2.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/pki.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/tls.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/string_extend.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/pidcrypt.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/pidcrypt_util.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/prng4.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/rng.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/md5.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/aes_core.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/aes_cbc.js"></script>
      
      <script type="text/javascript">

      // load flash tester
      swfobject.embedSWF(
         "/bitmunk/test/Test.swf", "flashTest", "0", "0", "9.0.0",
         "/bitmunk/js/swfobject/expressInstall.swf",
         {}, {allowscriptaccess: 'always'}, {});

      // set krypto alias
      var krypto = window.krypto;

      var canvas_clear = function()
      {
         var canvas = document.getElementById("canvas");
         var ctx = canvas.getContext("2d");
         ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      var random_krypto = function()
      {
         do_random(krypto.random);
      };

      var random_pidcrypt = function()
      {
         do_random(
         {
            getBytes: function(count)
            {
               var ba = [];
               ba[count - 1] = 0;
               var sr = new SecureRandom();
               sr.nextBytes(ba);
               var b = '';
               for(var i = 0; i < count; i++)
               {
                  b += String.fromCharCode(ba[i]);
               }
               return b;
            }
         });
      };
      
      var do_random = function(inf)
      {
         console.log('painting canvas');
         var canvas = document.getElementById("canvas");
         var ctx = canvas.getContext("2d");
         var imgData = ctx.createImageData(canvas.width, canvas.height);

         // generate random bytes
         var bytes = inf.getBytes(canvas.width * canvas.height * 3);
         var n = 0;
         for(var x = 0; x < imgData.width; x++)
         {
            for(var y = 0; y < imgData.height; y++)
            {
               // index of the pixel in the array
               var idx = (x + y * imgData.width) * 4;

               // set values
               imgData.data[idx + 0] = bytes.charCodeAt(n++); // Red
               imgData.data[idx + 1] = bytes.charCodeAt(n++); // Green
               imgData.data[idx + 2] = bytes.charCodeAt(n++); // Blue
               imgData.data[idx + 3] = 255;        // Alpha
            }
         }

         ctx.putImageData(imgData, 0, 0);
         console.log('done');
      };

      var test_buffer = function()
      {
         ba = krypto.util.createBuffer();
         ba.putByte(1);
         ba.putByte(2);
         ba.putByte(3);
         ba.putByte(4);
         ba.putInt32(4);
         ba.putByte(1);
         ba.putByte(2);
         ba.putByte(3);
         ba.putInt32(4294967295);
         var hex = ba.toHex();
         var bytes = [];
         while(ba.length() > 0)
         {
            bytes.push(ba.getByte());
         }
         var expect = [1, 2, 3, 4, 0, 0, 0, 4, 1, 2, 3, 255, 255, 255, 255];
         var exHex = '0102030400000004010203ffffffff';
         console.log('ba', bytes);
         console.log('ex', expect);
         console.log('assert', hex === exHex);

         var buf = krypto.util.createBuffer();
         buf.putBytes(krypto.util.hexToBytes(exHex));
         console.log('assert', buf.toHex() === exHex);
      };

      var test_base64 = function()
      {
         var s1 = '00010203050607080A0B0C0D0F1011121415161719';
         var s2 = 'MDAwMTAyMDMwNTA2MDcwODBBMEIwQzBEMEYxMDExMTIxNDE1MTYxNzE5';
         var out = krypto.util.encode64(s1);
         console.log('out', out);
         console.log('ex', s2);
         out = krypto.util.decode64(s2);
         console.log('out', out);
         console.log('ex', s1);
      };

      var test_base64_speed = function()
      {
         var str, count, st, et;

         str = '';
         for(var i = 0; i < 100; i++)
         {
            str += '00010203050607080A0B0C0D0F1011121415161719';
         }
         count = 5000;
         st = +new Date();
         for(var i = 0; i < count; i++)
         {
            var out = krypto.util.encode64(str);
         }
         et = +new Date();
         console.log('time per encode', ((et - st)/count) + ' ms');

         str = '';
         for(var i = 0; i < 100; i++)
         {
            str += 'MDAwMTAyMDMwNTA2MDcwODBBMEIwQzBEMEYxMDExMTIxNDE1MTYxNzE5';
         }
         count = 5000;
         st = +new Date();
         for(var i = 0; i < count; i++)
         {
            var out = krypto.util.decode64(str);
         }
         et = +new Date();
         console.log('time per decode', ((et - st)/count) + ' ms');
      };

      var test_md5 = function()
      {
         // empty message sha-1
         var expect = 'd41d8cd98f00b204e9800998ecf8427e';
         var md = krypto.md.md5.create();
         console.log('digest', md.digest().toHex());
         console.log('assert', md.digest().toHex() === expect);

         // message md5 ('abc')
         expect = '900150983cd24fb0d6963f7d28e17f72';
         md.start();
         md.update('abc');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);

         // message md5 ('The quick brown fox jumps over the lazy dog')
         expect = '9e107d9d372bb6826bd81d3542a419d6';
         md.start();
         md.update('The quick brown fox jumps over the lazy dog');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
         
         // message md5 ('THIS IS A MESSAGE')
         expect = '78eebfd9d42958e3f31244f116ab7bbe';
         md.start();
         md.update('THIS IS ');
         md.update('A MESSAGE');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
      };

      var count_md5_speed = 300;
      var test_md5_speed = function()
      {
         // create input data
         var input = ['0123456789abcdef', '', '', '', ''];
         for(var i = 0; i < 4; ++i)
         {
            input[1] += input[0];
         }
         for(var i = 0; i < 4; ++i)
         {
            input[2] += input[1];
         }
         for(var i = 0; i < 4; ++i)
         {
            input[3] += input[2];
         }
         for(var i = 0; i < 8; ++i)
         {
            input[4] += input[3];
         }
         
         var md = krypto.md.md5.create();

         console.log('md5 times in 1000s of bytes/sec processed:');

         var st, et;
         var output =
            ['  16 bytes: ',
             '  64 bytes: ',
             ' 256 bytes: ',
             '1024 bytes: ',
             '8192 bytes: '];
         var s = [16, 64, 256, 1024, 8192];
         var t = [0, 0, 0, 0, 0];
         var ct = count_md5_speed;
         var c = [ct, ct, ct, ct, ct];
         for(var n = 0; n < 5; ++n)
         {
            var f = function(n)
            {
               setTimeout(function()
               {
                  for(var i = 0; i < c[n]; ++i)
                  {
                     md.start();
                     st = +new Date();
                     md.update(input[n]);
                     md.digest();
                     et = +new Date();
                     t[n] = t[n] + (et - st);
                  }
                  console.log(output[n], (t[n] / c[n] * s[n]) + 'k/sec');
               }, 0);
            }(n);
         }
      };
      
      var test_sha1 = function()
      {
         // empty message sha-1
         var expect = 'da39a3ee5e6b4b0d3255bfef95601890afd80709';
         var md = krypto.md.sha1.create();
         //console.log('digest', md.digest().toHex());
         console.log('assert', md.digest().toHex() === expect);

         // message sha-1 ('abc')
         expect = 'a9993e364706816aba3e25717850c26c9cd0d89d';
         md.start();
         md.update('abc');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
         
         // message sha-1 ('The quick brown fox jumps over the lazy dog')
         expect = '2fd4e1c67a2d28fced849ee1bb76e7391b93eb12';
         md.start();
         md.update('The quick brown fox jumps over the lazy dog');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
         
         // message sha-1 ('THIS IS A MESSAGE')
         expect = '5f24f4d6499fd2d44df6c6e94be8b14a796c071d';
         md.start();
         md.update('THIS IS ');
         md.update('A MESSAGE');
         //console.log('digest', md.digest().toHex());
         // assert twice to test continuing digest
         console.log('assert', md.digest().toHex() === expect);
         console.log('assert', md.digest().toHex() === expect);
      };

      var count_sha1_speed = 300;
      var test_sha1_speed = function()
      {
         // create input data
         var input = ['0123456789abcdef', '', '', '', ''];
         for(var i = 0; i < 4; ++i)
         {
            input[1] += input[0];
         }
         for(var i = 0; i < 4; ++i)
         {
            input[2] += input[1];
         }
         for(var i = 0; i < 4; ++i)
         {
            input[3] += input[2];
         }
         for(var i = 0; i < 8; ++i)
         {
            input[4] += input[3];
         }
         
         var md = krypto.md.sha1.create();

         console.log('sha-1 times in 1000s of bytes/sec processed:');

         var st, et;
         var output =
            ['  16 bytes: ',
             '  64 bytes: ',
             ' 256 bytes: ',
             '1024 bytes: ',
             '8192 bytes: '];
         var s = [16, 64, 256, 1024, 8192];
         var t = [0, 0, 0, 0, 0];
         var ct = count_sha1_speed;
         var c = [ct, ct, ct, ct, ct];
         for(var n = 0; n < 5; ++n)
         {
            var f = function(n)
            {
               setTimeout(function()
               {
                  for(var i = 0; i < c[n]; ++i)
                  {
                     md.start();
                     st = +new Date();
                     md.update(input[n]);
                     md.digest();
                     et = +new Date();
                     t[n] = t[n] + (et - st);
                  }
                  console.log(output[n], (t[n] / c[n] * s[n]) + 'k/sec');
               }, 0);
            }(n);
         }
      };

      var test_hmac = function()
      {
         var expect, key, hmac, mac;
         
         // md5 hmac 16-byte key
         expect = '9294727a3638bb1c13f48ef8158bfc9d';
         key = krypto.util.hexToBytes(
            '0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b');
         hmac = krypto.hmac.create();
         hmac.start('MD5', key);
         hmac.update('Hi There');
         mac = hmac.digest();
         //console.log('digest', mac.toHex());
         console.log('md5 with 16-byte key', mac.toHex() === expect);

         // md5 hmac short key
         expect = '750c783e6ab0b503eaa86e310a5db738';
         key = 'Jefe';
         hmac = krypto.hmac.create();
         hmac.start('MD5', key);
         hmac.update('what do ya want for nothing?');
         mac = hmac.digest();
         //console.log('digest', mac.toHex());
         console.log('md5 with short key', mac.toHex() === expect);

         // md5 hmac long key
         expect = '6b1ab7fe4bd7bf8f0b62e6ce61b9d0cd';
         key = krypto.util.hexToBytes(
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa');
         hmac = krypto.hmac.create();
         hmac.start('MD5', key);
         hmac.update('Test Using Larger Than Block-Size Key - Hash Key First');
         mac = hmac.digest();
         //console.log('digest', mac.toHex());
         console.log('md5 with 80-byte key', mac.toHex() === expect);

         // sha-1 hmac 20-byte key
         expect = 'b617318655057264e28bc0b6fb378c8ef146be00';
         key = krypto.util.hexToBytes(
            '0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b');
         hmac = krypto.hmac.create();
         hmac.start('SHA1', key);
         hmac.update('Hi There');
         mac = hmac.digest();
         //console.log('digest', mac.toHex());
         console.log('sha-1 with 20-byte key', mac.toHex() === expect);

         // sha-1 hmac short key
         expect = 'effcdf6ae5eb2fa2d27416d5f184df9c259a7c79';
         key = 'Jefe';
         hmac = krypto.hmac.create();
         hmac.start('SHA1', key);
         hmac.update('what do ya want for nothing?');
         mac = hmac.digest();
         //console.log('digest', mac.toHex());
         console.log('sha-1 with short key', mac.toHex() === expect);

         // sha-1 hmac long key
         expect = 'aa4ae5e15272d00e95705637ce8a3b55ed402112';
         key = krypto.util.hexToBytes(
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa' +
            'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa');
         hmac = krypto.hmac.create();
         hmac.start('SHA1', key);
         hmac.update('Test Using Larger Than Block-Size Key - Hash Key First');
         mac = hmac.digest();
         //console.log('digest', mac.toHex());
         console.log('sha-1 with 80-byte key', mac.toHex() === expect);
      };

      var test_oid = function()
      {
         var asn1 = krypto.asn1;
         var oid, der, expect;
         
         oid = '1.2.840.113549';
         der = asn1.oidToDer(oid);
         expect = '2a864886f70d';
         //console.log('hex', der.toHex());
         console.log('assert', expect === der.toHex());

         expect = oid;
         oid = asn1.derToOid(der);
         //console.log('oid', oid);
         console.log('assert', expect === oid);
      };

      var sPrivateKey =
      '-----BEGIN RSA PRIVATE KEY-----\r\n' +
      'MIICXQIBAAKBgQDL0EugUiNGMWscLAVM0VoMdhDZEJOqdsUMpx9U0YZI7szokJqQ\r\n' +
      'NIwokiQ6EonNnWSMlIvy46AhnlRYn+ezeTeU7eMGTkP3VF29vXBo+dLq5e+8VyAy\r\n' +
      'Q3FzM1wI4ts4hRACF8w6mqygXQ7i/SDu8/rXqRGtvnM+z0MYDdKo80efzwIDAQAB\r\n' +
      'AoGAIzkGONi5G+JifmXlLJdplom486p3upf4Ce2/7mqfaG9MnkyPSairKD/JXvfh\r\n' +
      'NNWkkN8DKKDKBcVVElPgORYT0qwrWc7ueLBMUCbRXb1ZyfEulimG0R3kjUh7NYau\r\n' +
      'DaIkVgfykXGSQMZx8FoaT6L080zd+0emKDDYRrb+/kgJNJECQQDoUZoiC2K/DWNY\r\n' +
      'h3/ppZ0ane2y4SBmJUHJVMPQ2CEgxsrJTxet668ckNCKaOP/3VFPoWC41f17DvKq\r\n' +
      'noYINNntAkEA4JbZBZBVUrQFhHlrpXT4jzqtO2RlKZzEq8qmFZfEErxOT1WMyyCi\r\n' +
      'lAQ5gUKardo1Kf0omC8Xq/uO9ZYdED55KwJBALs6cJ65UFaq4oLJiQPzLd7yokuE\r\n' +
      'dcj8g71PLBTW6jPxIiMFNA89nz3FU9wIVp+xbMNhSoMMKqIPVPC+m0Rn260CQQDA\r\n' +
      'I83fWK/mZWUjBM33a68KumRiH238v8XyQxj7+C8i6D8G2GXvkigFAehAkb7LZZd+\r\n' +
      'KLuGFyPlWv3fVWHf99KpAkBQFKk3MRMl6IGJZUEFQe4l5whm8LkGU4acSqv9B3xt\r\n' +
      'qROkCrsFrMPqjuuzEmyHoQZ64r2PLJg7FOuyhBnQUOt4\r\n' +
      '-----END RSA PRIVATE KEY-----';

      var sPublicKey =
      '-----BEGIN PUBLIC KEY-----\r\n' +
      'MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDL0EugUiNGMWscLAVM0VoMdhDZ\r\n' +
      'EJOqdsUMpx9U0YZI7szokJqQNIwokiQ6EonNnWSMlIvy46AhnlRYn+ezeTeU7eMG\r\n' +
      'TkP3VF29vXBo+dLq5e+8VyAyQ3FzM1wI4ts4hRACF8w6mqygXQ7i/SDu8/rXqRGt\r\n' +
      'vnM+z0MYDdKo80efzwIDAQAB\r\n' +
      '-----END PUBLIC KEY-----';
         
      var sCertPem =
      '-----BEGIN CERTIFICATE-----\r\n' +
      'MIIDIjCCAougAwIBAgIJANE2aHSbwpaRMA0GCSqGSIb3DQEBBQUAMGoxCzAJBgNV\r\n' +
      'BAYTAlVTMREwDwYDVQQIEwhWaXJnaW5pYTETMBEGA1UEBxMKQmxhY2tzYnVyZzEN\r\n' +
      'MAsGA1UEChMEVGVzdDENMAsGA1UECxMEVGVzdDEVMBMGA1UEAxMMbXlzZXJ2ZXIu\r\n' +
      'Y29tMB4XDTEwMDYxOTE3MzYyOFoXDTExMDYxOTE3MzYyOFowajELMAkGA1UEBhMC\r\n' +
      'VVMxETAPBgNVBAgTCFZpcmdpbmlhMRMwEQYDVQQHEwpCbGFja3NidXJnMQ0wCwYD\r\n' +
      'VQQKEwRUZXN0MQ0wCwYDVQQLEwRUZXN0MRUwEwYDVQQDEwxteXNlcnZlci5jb20w\r\n' +
      'gZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAMvQS6BSI0YxaxwsBUzRWgx2ENkQ\r\n' +
      'k6p2xQynH1TRhkjuzOiQmpA0jCiSJDoSic2dZIyUi/LjoCGeVFif57N5N5Tt4wZO\r\n' +
      'Q/dUXb29cGj50url77xXIDJDcXMzXAji2ziFEAIXzDqarKBdDuL9IO7z+tepEa2+\r\n' +
      'cz7PQxgN0qjzR5/PAgMBAAGjgc8wgcwwHQYDVR0OBBYEFPV1Y+DHXW6bA/r9sv1y\r\n' +
      'NJ8jAwMAMIGcBgNVHSMEgZQwgZGAFPV1Y+DHXW6bA/r9sv1yNJ8jAwMAoW6kbDBq\r\n' +
      'MQswCQYDVQQGEwJVUzERMA8GA1UECBMIVmlyZ2luaWExEzARBgNVBAcTCkJsYWNr\r\n' +
      'c2J1cmcxDTALBgNVBAoTBFRlc3QxDTALBgNVBAsTBFRlc3QxFTATBgNVBAMTDG15\r\n' +
      'c2VydmVyLmNvbYIJANE2aHSbwpaRMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEF\r\n' +
      'BQADgYEARdH2KOlJWTC1CS2y/PAvg4uiM31PXMC1hqSdJlnLM1MY4hRfuf9VyTeX\r\n' +
      'Y6FdybcyDLSxKn9id+g9229ci9/s9PI+QmD5vXd8yZyScLc2JkYB4GC6+9D1+/+x\r\n' +
      's2hzMxuK6kzZlP+0l9LGcraMQPGRydjCARZZm4Uegln9rh85XFQ=\r\n' +
      '-----END CERTIFICATE-----';

      var test_private_key_from_pem = function()
      {
         try
         {
            var privateKey = krypto.pki.privateKeyFromPem(sPrivateKey);
            console.log('privateKey', privateKey);
         }
         catch(ex)
         {
            console.log(ex);
         }
      };

      var test_public_key_from_pem = function()
      {
         try
         {
            var publicKey = krypto.pki.publicKeyFromPem(sPublicKey);
            console.log('publicKey', publicKey);
         }
         catch(ex)
         {
            console.log(ex);
         }
      };

      var test_cert_from_pem = function()
      {
         try
         {
            var cert = krypto.pki.certificateFromPem(sCertPem);
            console.log('cert', cert);
            console.log('CN', cert.subject.getField('CN').value);
            console.log('C', cert.subject.getField(
               {shortName: 'C'}).value);
            console.log('stateOrProvinceName', cert.subject.getField(
               {name: 'stateOrProvinceName'}).value);
            console.log('2.5.4.7', cert.subject.getField(
               {type: '2.5.4.7'}).value);
         }
         catch(ex)
         {
            console.log(ex);
         }
      };

      var sSignature =
         '9200ece65cdaed36bcc20b94c65af852e4f88f0b4fe5b249d54665f815992ac4' +
         '3a1399e65d938c6a7f16dd39d971a53ca66523209dbbfbcb67afa579dbb0c220' +
         '672813d9e6f4818f29b9becbb29da2032c5e422da97e0c39bfb7a2e7d568615a' +
         '5073af0337ff215a8e1b2332d668691f4fb731440055420c24ac451dd3c913f4';

      var test_verify_signature = function()
      {
         try
         {
            var key = krypto.pki.publicKeyFromPem(sPublicKey);
            var md = krypto.md.sha1.create();
            md.update('0123456789abcdef');
            var signature = krypto.util.hexToBytes(sSignature);
            var success = key.verify(md.digest().getBytes(), signature);
            console.log('assert', success === true);
         }
         catch(ex)
         {
            console.log(ex);
         }
      };

      var test_sign_verify = function()
      {
         try
         {
            var privateKey = krypto.pki.privateKeyFromPem(sPrivateKey);
            var publicKey = krypto.pki.publicKeyFromPem(sPublicKey);

            // do sign
            var md = krypto.md.sha1.create();
            md.update('0123456789abcdef');
            var st = +new Date();
            var signature = privateKey.sign(md);
            var et = +new Date();
            console.log('sign time', (et - st) + 'ms');

            // do verify
            st = +new Date();
            var success = publicKey.verify(md.digest().getBytes(), signature);
            et = +new Date();
            console.log('verify time', (et - st) + 'ms');
            console.log('assert', success === true);
         }
         catch(ex)
         {
            console.log(ex);
         }
      };
      
      var test_cert_verify = function()
      {
         try
         {
            var cert = krypto.pki.certificateFromPem(sCertPem, true);
            console.log('cert', cert);
            var success = cert.verify(cert);
            console.log('assert', success === true);
         }
         catch(ex)
         {
            console.log(ex);
         }
      };
      
      // 128-bit test keys
      var aesKeys = [
         '00010203050607080A0B0C0D0F101112',
         '14151617191A1B1C1E1F202123242526',
         '28292A2B2D2E2F30323334353738393A',
         '3C3D3E3F41424344464748494B4C4D4E',
         '50515253555657585A5B5C5D5F606162',
         '64656667696A6B6C6E6F707173747576',
         '78797A7B7D7E7F80828384858788898A',
         '8C8D8E8F91929394969798999B9C9D9E',
         'A0A1A2A3A5A6A7A8AAABACADAFB0B1B2',
         'B4B5B6B7B9BABBBCBEBFC0C1C3C4C5C6',
         'C8C9CACBCDCECFD0D2D3D4D5D7D8D9DA',
         'DCDDDEDFE1E2E3E4E6E7E8E9EBECEDEE',
         'F0F1F2F3F5F6F7F8FAFBFCFDFE010002',
         '04050607090A0B0C0E0F101113141516',
         '2C2D2E2F31323334363738393B3C3D3E',
         '40414243454647484A4B4C4D4F505152',
         '54555657595A5B5C5E5F606163646566',
         '68696A6B6D6E6F70727374757778797A',
         '7C7D7E7F81828384868788898B8C8D8E',
         'A4A5A6A7A9AAABACAEAFB0B1B3B4B5B6'];

      // create aes IV
      var aesIvBytes = krypto.random.getBytes(16);
      var aesIvWords = [];
      var aesIv = '';
      for(var i = 0; i < aesIvBytes.length; i++)
      {
         var hex = aesIvBytes.charCodeAt(i).toString(16);
         aesIv += (hex.length == 1) ? ('0' + hex) : hex;
      }
      for(var i = 0; i < aesIvBytes.length; i += 4)
      {
         aesIvWords.push(
            aesIvBytes.charCodeAt(i) << 24 ^
            aesIvBytes.charCodeAt(i + 1) << 16 ^
            aesIvBytes.charCodeAt(i + 2) << 8 ^
            aesIvBytes.charCodeAt(i + 3));
      }
      //console.log('aesIv', aesIv);

      // test data to encrypt
      var aesPlain =
         String.fromCharCode(0x00) +
         String.fromCharCode(0x11) +
         String.fromCharCode(0x22) +
         String.fromCharCode(0x33) +
         String.fromCharCode(0x44) +
         String.fromCharCode(0x55) +
         String.fromCharCode(0x66) +
         String.fromCharCode(0x77) +
         String.fromCharCode(0x88) +
         String.fromCharCode(0x99) +
         String.fromCharCode(0xaa) +
         String.fromCharCode(0xbb) +
         String.fromCharCode(0xcc) +
         String.fromCharCode(0xdd) +
         String.fromCharCode(0xee) +
         String.fromCharCode(0xff);
      var aesPlainWords = [
         0x00112233,
         0x44556677,
         0x8899aabb,
         0xccddeeff];
      var aesPlainBytes = [
         0x00, 0x11, 0x22, 0x33,
         0x44, 0x55, 0x66, 0x77,
         0x88, 0x99, 0xaa, 0xbb,
         0xcc, 0xdd, 0xee, 0xff];

      var aes_test_tables = function()
      {
         console.log('generating AES test tables ...');

         var xtime = new Array(256);
         for(var i = 0; i < 128; i++)
         {
            xtime[i] = i << 1;
            xtime[i + 128] = (i + 128) << 1 ^ 0x11B;
         }
         console.log('first xtime', xtime);   

         // compute xtime table which maps b onto GF(b, 0x02)
         // compute anti-log and log tables
         var xtime = new Array(256);
         var atable = new Array(256);
         var ltable = new Array(256);
         var b = 1, b2;
         for(var i = 0; i < 256; i++)
         {
            atable[i] = b;
            ltable[b] = i;
            b2 = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1 & 0xFF);
            xtime[b] = b2;
            b ^= b2;
         }
         xtime[0] = 0;
         atable[255] = atable[0];
         ltable[0] = 0;

         // compute sbox and isbox
         var sbox = new Array(256);
         var isbox = new Array(256);
         for(var i = 0; i < 256; i++)
         {
            // multiplicative inverse: 0 or atable[255 - ltable[i]]
            b = (i == 0) ? 0 : atable[255 - ltable[i]];

            // SubBytes() affine transformation 
            b = b ^ (b << 1) ^ (b << 2) ^ (b << 3) ^ (b << 4);
            b = (b >> 8) ^ (b & 0xFF) ^ 0x63;
            sbox[i] = b;
            isbox[b] = i;
         }
         
         var inv = [];
         for(var i = 0; i < 256; i++)
         {
            inv[i] = (i == 0) ? 0 : atable[(255 - ltable[i])];
         }
         console.log('inv', inv);

         // inverse: atable[255 - ltable[b]];
         console.log('atable', atable);
         console.log('ltable', ltable);
         console.log('xtime', xtime);

         console.log('xtime(61)=' + xtime[61] + ',gmul=' +
               atable[(ltable[61] + ltable[2])%255]);
         console.log('sbox', sbox);
         console.log('isbox', isbox);
      };

      var word_array_to_string = function(wa)
      {
         // get words from buffer
         if(wa.constructor != Array)
         {
            var bytes = wa.bytes();
            wa = [];
            for(var i = 0; i < bytes.length; i += 4)
            {
               wa.push(
                  bytes.charCodeAt(i) << 24 ^
                  bytes.charCodeAt(i + 1) << 16 ^
                  bytes.charCodeAt(i + 2) << 8 ^
                  bytes.charCodeAt(i + 3));
            }
         }
         
         var str = '[';
         for(var i = 0; i < wa.length; i++)
         {
            // handle signed hex
            if(wa[i] < 0)
            {
               str += (wa[i] + 0xFFFFFFFF + 1).toString(16);
            }
            else
            {
               str += wa[i].toString(16);
            }
            if(i + 1 < wa.length)
            {
               str += ',';
            }
         }
         str += ']';
         return str;
      };

      var aes_krypto_128 = function()
      {
         console.log('testing krypto AES-128 ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         var plain = block;
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         
         var expect = [];
         expect.push(0x69c4e0d8);
         expect.push(0x6a7b0430);
         expect.push(0xd8cdb780);
         expect.push(0x70b4c55a);

         var output = [];
         var w = krypto.aes._expandKey(key, false);
         krypto.aes._updateBlock(w, block, output, false);
         console.log('ciphered', word_array_to_string(output));
         console.log('expect', word_array_to_string(expect));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(expect));

         block = output;
         output = [];
         w = krypto.aes._expandKey(key, true);
         krypto.aes._updateBlock(w, block, output, true);
         console.log('plain', word_array_to_string(output));
         console.log('expect', word_array_to_string(plain));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(plain));
      };

      var aes_krypto_192 = function()
      {
         console.log('testing krypto AES-192 ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         var plain = block;
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         key.push(0x10111213);
         key.push(0x14151617);
         
         var expect = [];
         expect.push(0xdda97ca4);
         expect.push(0x864cdfe0);
         expect.push(0x6eaf70a0);
         expect.push(0xec0d7191);

         var output = [];
         var w = krypto.aes._expandKey(key, false);
         krypto.aes._updateBlock(w, block, output, false);
         console.log('ciphered', word_array_to_string(output));
         console.log('expect', word_array_to_string(expect));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(expect));

         block = output;
         output = [];
         w = krypto.aes._expandKey(key, true);
         krypto.aes._updateBlock(w, block, output, true);
         console.log('plain', word_array_to_string(output));
         console.log('expect', word_array_to_string(plain));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(plain));
      };

      var aes_krypto_256 = function()
      {
         console.log('testing krypto AES-256 ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         var plain = block;
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         key.push(0x10111213);
         key.push(0x14151617);
         key.push(0x18191a1b);
         key.push(0x1c1d1e1f);
         
         var expect = [];
         expect.push(0x8ea2b7ca);
         expect.push(0x516745bf);
         expect.push(0xeafc4990);
         expect.push(0x4b496089);

         var output = [];
         var w = krypto.aes._expandKey(key, false);
         krypto.aes._updateBlock(w, block, output, false);
         console.log('ciphered', word_array_to_string(output));
         console.log('expect', word_array_to_string(expect));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(expect));

         block = output;
         output = [];
         w = krypto.aes._expandKey(key, true);
         krypto.aes._updateBlock(w, block, output, true);
         console.log('plain', word_array_to_string(output));
         console.log('expect', word_array_to_string(plain));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(plain));
      };

      var count_128_speed = 70000;

      var aes_krypto_128_speed = function()
      {
         console.log('testing krypto AES-128 speed ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = count_128_speed;
         for(var i = 0; i < count; i++)
         {
            var output = [];
            var w = krypto.aes._expandKey(key, false);
            now = +new Date();
            krypto.aes._updateBlock(w, block, output, false);
            totalEncrypt += (+new Date()) - now;

            block = output;
            output = [];
            w = krypto.aes._expandKey(key, true);
            now = +new Date();
            krypto.aes._updateBlock(w, block, output, true);
            totalDecrypt += (+new Date()) - now;
         }

         console.log('encrypt time: ' + (totalEncrypt / count) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / count) + ' ms');
         console.log('krypto aes-128 speed test complete.');
      };

      var aes_krypto = function()
      {
         console.log('testing AES (krypto) ...');

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = 100;
         var totalTimes = aesKeys.length * count;
         for(var n = 0; n < count; n++)
         {
            for(var i = 0; i < aesKeys.length; i++)
            {
               var k = aesKeys[i];
               var key = [];
               key.push(parseInt(k.substr(0, 8), 16));
               key.push(parseInt(k.substr(8, 8), 16));
               key.push(parseInt(k.substr(16, 8), 16));
               key.push(parseInt(k.substr(24, 8), 16));
               
               var we = krypto.aes._expandKey(key, false);
               var wd = krypto.aes._expandKey(key, true);
               var block = aesPlainWords;
               var output = [];
               
               // encrypt
               now = +new Date();
               krypto.aes._updateBlock(we, block, output, false);
               totalEncrypt += (+new Date()) - now;
               
               // decrypt
               block = output;
               output = [];
               now = +new Date();
               krypto.aes._updateBlock(wd, block, output, true);
               totalDecrypt += (+new Date()) - now;
            }
         }
         
         console.log('encrypt time: ' + (totalEncrypt / totalTimes) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / totalTimes) + ' ms');
         console.log('krypto aes test complete.');
      };

      var aes_krypto_cbc = function()
      {
         console.log('testing AES-CBC (krypto) ...');

         for(var i = 0; i < aesKeys.length; i++)
         {
            var k = aesKeys[i];
            var key = [];
            key.push(parseInt(k.substr(0, 8), 16));
            key.push(parseInt(k.substr(8, 8), 16));
            key.push(parseInt(k.substr(16, 8), 16));
            key.push(parseInt(k.substr(24, 8), 16));
            
            var input = krypto.util.createBuffer(aesPlain);
            
            // encrypt
            cipher = krypto.aes.createEncryptionCipher(key);
            cipher.start(aesIvWords);
            cipher.update(input);
            cipher.finish();
            
            // decrypt
            var ct = cipher.output;
            cipher = krypto.aes.createDecryptionCipher(key);
            cipher.start(aesIvWords);
            cipher.update(ct);
            cipher.finish();
            
            console.log('plain', word_array_to_string(cipher.output));
            console.log('expect', word_array_to_string(aesPlainWords));
            console.log('assert',
               word_array_to_string(cipher.output) ==
               word_array_to_string(aesPlainWords));
         }
      };

      var aes_krypto_cbc_speed = function()
      {
         console.log('testing AES-CBC (krypto) ...');

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = 2000;
         var totalTimes = aesKeys.length * count;
         for(var n = 0; n < count; n++)
         {
            for(var i = 0; i < aesKeys.length; i++)
            {
               var k = aesKeys[i];
               var key = [];
               key.push(parseInt(k.substr(0, 8), 16));
               key.push(parseInt(k.substr(8, 8), 16));
               key.push(parseInt(k.substr(16, 8), 16));
               key.push(parseInt(k.substr(24, 8), 16));
               
               var input = krypto.util.createBuffer(aesPlain);
               
               // encrypt
               cipher = krypto.aes.startEncrypting(key, aesIvWords);
               now = +new Date();
               cipher.update(input);
               cipher.finish();
               totalEncrypt += (+new Date()) - now;
               
               // decrypt
               var ct = cipher.output;
               cipher = krypto.aes.startDecrypting(key, aesIvWords);
               now = +new Date();
               cipher.update(ct);
               cipher.finish();
               totalDecrypt += (+new Date()) - now;
            }
         }

         console.log('encrypt time: ' + (totalEncrypt / totalTimes) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / totalTimes) + ' ms');
         console.log('krypto aes test complete.');
      };

      var aes_jscrypto_128_speed = function()
      {
         console.log('testing AES (jscrypto) speed ...');

         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = count_128_speed;
         for(var i = 0; i < count; i++)
         {
            var cipher = new aes(key);
            var output = [];
            now = +new Date();
            cipher.encryptBlock(block, output, false);
            totalEncrypt += (+new Date()) - now;

            block = output;
            output = [];
            now = +new Date();
            cipher.decryptBlock(block, output);
            totalDecrypt += (+new Date()) - now;
         }

         console.log('encrypt time: ' + (totalEncrypt / count) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / count) + ' ms');
         console.log('jscrypto aes-128 speed test complete.');
      };
      
      var aes_sjcl_128_speed = function()
      {
         console.log('testing AES (sjcl) speed ...');

         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = count_128_speed;
         for(var i = 0; i < count; i++)
         {
            var cipher = new sjcl.cipher.aes(key);
            var output;
            now = +new Date();
            output = cipher.encrypt(block);
            totalEncrypt += (+new Date()) - now;

            block = output;
            output = [];
            now = +new Date();
            output = cipher.decrypt(block);
            totalDecrypt += (+new Date()) - now;
         }

         console.log('encrypt time: ' + (totalEncrypt / count) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / count) + ' ms');
         console.log('sjcl aes-128 speed test complete.');
      };
      
      var aes_pid_crypt = function()
      {
         console.log('testing AES (pidcrypt) ...');

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         for(var i = 0; i < aesKeys.length; i++)
         {
            var cipher = new pidCrypt.AES.CBC();
            var key = aesKeys[i];
            var plainBytes = aesPlainBytes;

            // encrypt
            cipher.initByValues('', key, aesIv);
            now = +new Date();
            var cipherBytes = cipher.encryptRaw(plainBytes);
            totalEncrypt += (+new Date()) - now;
            
            // decrypt
            cipher.initByValues('', key, aesIv);
            now = +new Date();
            cipher.decryptRaw(cipherBytes);
            totalDecrypt += (+new Date()) - now;

            /* Base64-encoding used here
            // encrypt
            cipher.initByValues(aesPlain, key, aesIv);
            now = +new Date();
            var ciphered = cipher.encrypt();
            totalEncrypt += (+new Date()) - now;

            // decrypt
            cipher.initByValues(ciphered, key, aesIv);
            now = +new Date();
            cipher.decrypt();
            totalDecrypt += (+new Date()) - now;
            */
         }

         var len = aesKeys.length;
         console.log('encrypt time: ' + (totalEncrypt / len) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / len) + ' ms');
         console.log('pidcrypt aes test complete.');
      };

      var aes_as3crypto = function()
      {
         console.log('testing AES (as3crypto) ...');
         document.getElementById('flashTest').aes();
      };

      var aes_as3crypto_cbc = function()
      {
         console.log('testing AES-CBC (as3crypto) ...');
         document.getElementById('flashTest').aes_cbc();
      };

      var aes_flash_128 = function()
      {
         console.log('testing AES (flash 128) ...');
         document.getElementById('flashTest').aes_flash_128();
      };

      var aes_flash_test = function()
      {
         console.log('testing AES (flash) ...');
         document.getElementById('flashTest').aes_test();
      };

      var tls_handshake = function()
      {
         console.log('testing TLS handshake ...');

         // FIXME: implement calls to create each type of client message
         // FIXME: implement calls to parse each type of server message
         // FIXME: test those
         // FIXME: implement state changes

         // FIXME: get byte array stuff in order for data in tls records.
         // FIXME: need to be able to write a TLS vector into a byte array, etc.
         // FIXME: run regression tests for aes

         // FIXME: update socket pool in flash to be able to set conditional
         // event handlers ... ie: js sets a handler for when X number of
         // bytes are received so js only gets the event once that has happened
      };

      </script>
   </head>
   <body>
      <p>Use the controls below to test krypto stuff.</p>
      <div id="random_controls">
         <button id="clear" onclick="javascript:return canvas_clear();">clear</button>
         <button id="random1" onclick="javascript:return random_krypto();">krypto</button>
         <button id="random2" onclick="javascript:return random_pidcrypt();">pidcrypt</button>
      </div>
      <canvas id="canvas" width="300" height="300"></canvas>
      <div id="util_controls">
         <button id="buffer" onclick="javascript:return test_buffer();">buffer</button>
         <button id="base64" onclick="javascript:return test_base64();">base64</button>
         <button id="base64_speed" onclick="javascript:return test_base64_speed();">base64 speed</button>
      </div>
      <div id="hash_controls">
         <button id="md5" onclick="javascript:return test_md5();">md5</button>
         <button id="md5_speed" onclick="javascript:return test_md5_speed();">md5 speed</button>
         <button id="sha1" onclick="javascript:return test_sha1();">sha1</button>
         <button id="sha1_speed" onclick="javascript:return test_sha1_speed();">sha1 speed</button>
         <button id="hmac" onclick="javascript:return test_hmac();">hmac</button>
      </div>
      <div id="pki">
         <button id="oid" onclick="javascript:return test_oid();">asn.1 oid</button>
         <button id="private_key_pem" onclick="javascript:return test_private_key_from_pem();">private key from pem</button>
         <button id="public_key_pem" onclick="javascript:return test_public_key_from_pem();">public key from pem</button>
         <button id="cert_pem" onclick="javascript:return test_cert_from_pem();">cert from pem</button>
         <button id="verify_signature" onclick="javascript:return test_verify_signature();">verify signature</button>
         <button id="sign_verify" onclick="javascript:return test_sign_verify();">sign and verify signature</button>
         <button id="verify_cert" onclick="javascript:return test_cert_verify();">verify cert</button>
      </div>
      <div id="flashTest">
         <p>Could not load the flash Test.</p>
      </div>
      <div id="aes_controls">
         <button id="aes_krypto128" onclick="javascript:return aes_krypto_128();">krypto 128</button>
         <button id="aes_krypto192" onclick="javascript:return aes_krypto_192();">krypto 192</button>
         <button id="aes_krypto256" onclick="javascript:return aes_krypto_256();">krypto 256</button>
         <button id="aes__krypto128_speed" onclick="javascript:return aes_krypto_128_speed();">krypto 128 speed</button>
         <button id="aes__jscrypto128_speed" onclick="javascript:return aes_jscrypto_128_speed();">jscrypto 128 speed</button>
         <button id="aes__sjcl128_speed" onclick="javascript:return aes_sjcl_128_speed();">sjcl 128 speed</button>
         <br />
         <button id="aes_krypto" onclick="javascript:return aes_krypto();">krypto</button>
         <button id="aes_krypto_cbc" onclick="javascript:return aes_krypto_cbc();">krypto CBC</button>         <button id="aes6" onclick="javascript:return aes_krypto_cbc_speed();">krypto CBC speed</button>
         <button id="aes_pidcrypt" onclick="javascript:return aes_pid_crypt();">pidcrypt</button>
         <button id="aes_as3crypto" onclick="javascript:return aes_as3crypto();">as3crypto</button>
         <button id="aes_as3crypto_cbc" onclick="javascript:return aes_as3crypto_cbc();">as3crypto CBC</button>
         <button id="aes_flash128" onclick="javascript:return aes_flash_128();">flash 128</button>
         <button id="aes_flash" onclick="javascript:return aes_flash_test();">flash test</button>
         <br />
         <button id="tls_handshake" onclick="javascript:return tls_handshake();">tls handshake</button>
      </div>
   </body>
</html>
