<html>
   <head>
      <style> 
      canvas {
        background: black;
      }
      </style>
      <script type="text/javascript" src="/bitmunk/js/swfobject/swfobject.js"></script>
      <script type="text/javascript" src="/bitmunk/js/jquery.js"></script>
      <script type="text/javascript" src="/bitmunk/test/jscrypto/jscrypto.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/random.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/utils.js"></script>
      <script type="text/javascript" src="/bitmunk/test/krypto/aes.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/string_extend.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/pidcrypt.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/pidcrypt_util.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/prng4.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/rng.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/md5.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/aes_core.js"></script>
      <script type="text/javascript" src="/bitmunk/test/pidcrypt/aes_cbc.js"></script>
      
      <script type="text/javascript">

      // load flash tester
      swfobject.embedSWF(
         "/bitmunk/test/Test.swf", "flashTest", "0", "0", "9.0.0",
         "/bitmunk/js/swfobject/expressInstall.swf",
         {}, {allowscriptaccess: 'always'}, {});

      // set krypto alias
      var krypto = window.krypto;

      var canvas_clear = function()
      {
         var canvas = document.getElementById("canvas");
         var ctx = canvas.getContext("2d");
         ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      var random_krypto = function()
      {
         do_random(krypto.random);
      };

      var random_pidcrypt = function()
      {
         do_random(
         {
            getBytes: function(count)
            {
               var ba = [];
               ba[count - 1] = 0;
               var sr = new SecureRandom();
               sr.nextBytes(ba);
               return ba;
            }
         });
      };
      
      var do_random = function(inf)
      {
         console.log('painting canvas');
         var canvas = document.getElementById("canvas");
         var ctx = canvas.getContext("2d");
         var imgData = ctx.createImageData(canvas.width, canvas.height);

         // generate random bytes
         var bytes = inf.getBytes(canvas.width * canvas.height * 3);
         var n = 0;
         for(var x = 0; x < imgData.width; x++)
         {
            for(var y = 0; y < imgData.height; y++)
            {
               // index of the pixel in the array
               var idx = (x + y * imgData.width) * 4;

               // set values
               imgData.data[idx + 0] = bytes[n++]; // Red channel
               imgData.data[idx + 1] = bytes[n++]; // Green channel
               imgData.data[idx + 2] = bytes[n++]; // Blue channel
               imgData.data[idx + 3] = 255;        // Alpha channel
            }
         }

         ctx.putImageData(imgData, 0, 0);
         console.log('done');
      };

      var test_buffer = function()
      {
         ba = krypto.utils.createBuffer();
         ba.putByte(1);
         ba.putByte(2);
         ba.putByte(3);
         ba.putByte(4);
         ba.putInt32(4);
         ba.putByte(1);
         ba.putByte(2);
         ba.putByte(3);
         ba.putInt32(4294967295);
         var bytes = [];
         while(ba.length() > 0)
         {
            bytes.push(ba.getByte());
         }
         var expect = [1, 2, 3, 4, 0, 0, 0, 4, 1, 2, 3, 255, 255, 255, 255];
         console.log('ba', bytes);
         console.log('ex', expect);
      };

      // 128-bit test keys
      var aesKeys = [
         '00010203050607080A0B0C0D0F101112',
         '14151617191A1B1C1E1F202123242526',
         '28292A2B2D2E2F30323334353738393A',
         '3C3D3E3F41424344464748494B4C4D4E',
         '50515253555657585A5B5C5D5F606162',
         '64656667696A6B6C6E6F707173747576',
         '78797A7B7D7E7F80828384858788898A',
         '8C8D8E8F91929394969798999B9C9D9E',
         'A0A1A2A3A5A6A7A8AAABACADAFB0B1B2',
         'B4B5B6B7B9BABBBCBEBFC0C1C3C4C5C6',
         'C8C9CACBCDCECFD0D2D3D4D5D7D8D9DA',
         'DCDDDEDFE1E2E3E4E6E7E8E9EBECEDEE',
         'F0F1F2F3F5F6F7F8FAFBFCFDFE010002',
         '04050607090A0B0C0E0F101113141516',
         '2C2D2E2F31323334363738393B3C3D3E',
         '40414243454647484A4B4C4D4F505152',
         '54555657595A5B5C5E5F606163646566',
         '68696A6B6D6E6F70727374757778797A',
         '7C7D7E7F81828384868788898B8C8D8E',
         'A4A5A6A7A9AAABACAEAFB0B1B3B4B5B6'];

      // create aes IV
      var aesIvBytes = krypto.random.getBytes(16);
      var aesIvWords = [];
      var aesIv = '';
      for(var i = 0; i < aesIvBytes.length; i++)
      {
         var hex = aesIvBytes[i].toString(16);
         aesIv += (hex.length == 1) ? ('0' + hex) : hex;
      }
      for(var i = 0; i < aesIvBytes.length; i += 4)
      {
         aesIvWords.push(
            aesIvBytes[i] << 24 ^
            aesIvBytes[i + 1] << 16 ^
            aesIvBytes[i + 2] << 8 ^
            aesIvBytes[i + 3]);
      }
      console.log('aesIv', aesIv);

      // test data to encrypt
      var aesPlain =
         String.fromCharCode(0x00) +
         String.fromCharCode(0x11) +
         String.fromCharCode(0x22) +
         String.fromCharCode(0x33) +
         String.fromCharCode(0x44) +
         String.fromCharCode(0x55) +
         String.fromCharCode(0x66) +
         String.fromCharCode(0x77) +
         String.fromCharCode(0x88) +
         String.fromCharCode(0x99) +
         String.fromCharCode(0xaa) +
         String.fromCharCode(0xbb) +
         String.fromCharCode(0xcc) +
         String.fromCharCode(0xdd) +
         String.fromCharCode(0xee) +
         String.fromCharCode(0xff);
      var aesPlainWords = [
         0x00112233,
         0x44556677,
         0x8899aabb,
         0xccddeeff];
      var aesPlainBytes = [
         0x00, 0x11, 0x22, 0x33,
         0x44, 0x55, 0x66, 0x77,
         0x88, 0x99, 0xaa, 0xbb,
         0xcc, 0xdd, 0xee, 0xff];

      var aes_test_tables = function()
      {
         console.log('generating AES test tables ...');

         var xtime = new Array(256);
         for(var i = 0; i < 128; i++)
         {
            xtime[i] = i << 1;
            xtime[i + 128] = (i + 128) << 1 ^ 0x11B;
         }
         console.log('first xtime', xtime);   

         // compute xtime table which maps b onto GF(b, 0x02)
         // compute anti-log and log tables
         var xtime = new Array(256);
         var atable = new Array(256);
         var ltable = new Array(256);
         var b = 1, b2;
         for(var i = 0; i < 256; i++)
         {
            atable[i] = b;
            ltable[b] = i;
            b2 = (b & 128) ? (b << 1 ^ 0x11b) : (b << 1 & 0xFF);
            xtime[b] = b2;
            b ^= b2;
         }
         xtime[0] = 0;
         atable[255] = atable[0];
         ltable[0] = 0;

         // compute sbox and isbox
         var sbox = new Array(256);
         var isbox = new Array(256);
         for(var i = 0; i < 256; i++)
         {
            // multiplicative inverse: 0 or atable[255 - ltable[i]]
            b = (i == 0) ? 0 : atable[255 - ltable[i]];

            // SubBytes() affine transformation 
            b = b ^ (b << 1) ^ (b << 2) ^ (b << 3) ^ (b << 4);
            b = (b >> 8) ^ (b & 0xFF) ^ 0x63;
            sbox[i] = b;
            isbox[b] = i;
         }
         
         var inv = [];
         for(var i = 0; i < 256; i++)
         {
            inv[i] = (i == 0) ? 0 : atable[(255 - ltable[i])];
         }
         console.log('inv', inv);

         // inverse: atable[255 - ltable[b]];
         console.log('atable', atable);
         console.log('ltable', ltable);
         console.log('xtime', xtime);

         console.log('xtime(61)=' + xtime[61] + ',gmul=' +
               atable[(ltable[61] + ltable[2])%255]);
         console.log('sbox', sbox);
         console.log('isbox', isbox);
      };

      var word_array_to_string = function(wa)
      {
         // get words from buffer
         if(wa.constructor != Array)
         {
            var bytes = wa.bytes();
            wa = [];
            for(var i = 0; i < bytes.length; i += 4)
            {
               wa.push(
                  bytes.charCodeAt(i) << 24 ^
                  bytes.charCodeAt(i + 1) << 16 ^
                  bytes.charCodeAt(i + 2) << 8 ^
                  bytes.charCodeAt(i + 3));
            }
         }
         
         var str = '[';
         for(var i = 0; i < wa.length; i++)
         {
            // handle signed hex
            if(wa[i] < 0)
            {
               str += (wa[i] + 0xFFFFFFFF + 1).toString(16);
            }
            else
            {
               str += wa[i].toString(16);
            }
            if(i + 1 < wa.length)
            {
               str += ',';
            }
         }
         str += ']';
         return str;
      };

      var aes_krypto_128 = function()
      {
         console.log('testing krypto AES-128 ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         var plain = block;
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         
         var expect = [];
         expect.push(0x69c4e0d8);
         expect.push(0x6a7b0430);
         expect.push(0xd8cdb780);
         expect.push(0x70b4c55a);

         var output = [];
         var w = krypto.aes._expandKey(key, false);
         krypto.aes._updateBlock(w, block, output, false);
         console.log('ciphered', word_array_to_string(output));
         console.log('expect', word_array_to_string(expect));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(expect));

         block = output;
         output = [];
         w = krypto.aes._expandKey(key, true);
         krypto.aes._updateBlock(w, block, output, true);
         console.log('plain', word_array_to_string(output));
         console.log('expect', word_array_to_string(plain));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(plain));
      };

      var aes_krypto_192 = function()
      {
         console.log('testing krypto AES-192 ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         var plain = block;
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         key.push(0x10111213);
         key.push(0x14151617);
         
         var expect = [];
         expect.push(0xdda97ca4);
         expect.push(0x864cdfe0);
         expect.push(0x6eaf70a0);
         expect.push(0xec0d7191);

         var output = [];
         var w = krypto.aes._expandKey(key, false);
         krypto.aes._updateBlock(w, block, output, false);
         console.log('ciphered', word_array_to_string(output));
         console.log('expect', word_array_to_string(expect));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(expect));

         block = output;
         output = [];
         w = krypto.aes._expandKey(key, true);
         krypto.aes._updateBlock(w, block, output, true);
         console.log('plain', word_array_to_string(output));
         console.log('expect', word_array_to_string(plain));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(plain));
      };

      var aes_krypto_256 = function()
      {
         console.log('testing krypto AES-256 ...');
         
         var block = [];
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         var plain = block;
         
         var key = [];
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         key.push(0x10111213);
         key.push(0x14151617);
         key.push(0x18191a1b);
         key.push(0x1c1d1e1f);
         
         var expect = [];
         expect.push(0x8ea2b7ca);
         expect.push(0x516745bf);
         expect.push(0xeafc4990);
         expect.push(0x4b496089);

         var output = [];
         var w = krypto.aes._expandKey(key, false);
         krypto.aes._updateBlock(w, block, output, false);
         console.log('ciphered', word_array_to_string(output));
         console.log('expect', word_array_to_string(expect));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(expect));

         block = output;
         output = [];
         w = krypto.aes._expandKey(key, true);
         krypto.aes._updateBlock(w, block, output, true);
         console.log('plain', word_array_to_string(output));
         console.log('expect', word_array_to_string(plain));
         console.log('assert',
            word_array_to_string(output) ==
            word_array_to_string(plain));
      };

      var aes_krypto = function()
      {
         console.log('testing AES (krypto) ...');

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = 100;
         var totalTimes = aesKeys.length * count;
         for(var n = 0; n < count; n++)
         {
            for(var i = 0; i < aesKeys.length; i++)
            {
               var k = aesKeys[i];
               var key = [];
               key.push(parseInt(k.substr(0, 8), 16));
               key.push(parseInt(k.substr(8, 8), 16));
               key.push(parseInt(k.substr(16, 8), 16));
               key.push(parseInt(k.substr(24, 8), 16));
               
               var we = krypto.aes._expandKey(key, false);
               var wd = krypto.aes._expandKey(key, true);
               var block = aesPlainWords;
               var output = [];
               
               // encrypt
               now = +new Date();
               krypto.aes._updateBlock(we, block, output, false);
               totalEncrypt += (+new Date()) - now;
               
               // decrypt
               block = output;
               output = [];
               now = +new Date();
               krypto.aes._updateBlock(wd, block, output, false);
               totalDecrypt += (+new Date()) - now;
            }
         }
         
         console.log('encrypt time: ' + (totalEncrypt / totalTimes) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / totalTimes) + ' ms');
         console.log('krypto aes test complete.');
      };

      var aes_krypto_cbc = function()
      {
         console.log('testing AES-CBC (krypto) ...');

         for(var i = 0; i < aesKeys.length; i++)
         {
            var k = aesKeys[i];
            var key = [];
            key.push(parseInt(k.substr(0, 8), 16));
            key.push(parseInt(k.substr(8, 8), 16));
            key.push(parseInt(k.substr(16, 8), 16));
            key.push(parseInt(k.substr(24, 8), 16));
            
            var input = krypto.utils.createBuffer(aesPlain);
            
            // encrypt
            cipher = krypto.aes.startEncrypting(key, aesIvWords);
            cipher.update(input);
            cipher.finish();
            
            // decrypt
            var ct = cipher.output;
            cipher = krypto.aes.startDecrypting(key, aesIvWords);
            cipher.update(ct);
            cipher.finish();
            
            console.log('plain', word_array_to_string(cipher.output));
            console.log('expect', word_array_to_string(aesPlainWords));
            console.log('assert',
               word_array_to_string(cipher.output) ==
               word_array_to_string(aesPlainWords));
         }
      };

      var aes_krypto_cbc_speed = function()
      {
         console.log('testing AES-CBC (krypto) ...');

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         var count = 100;
         var totalTimes = aesKeys.length * count;
         for(var n = 0; n < count; n++)
         {
            for(var i = 0; i < aesKeys.length; i++)
            {
               var k = aesKeys[i];
               var key = [];
               key.push(parseInt(k.substr(0, 8), 16));
               key.push(parseInt(k.substr(8, 8), 16));
               key.push(parseInt(k.substr(16, 8), 16));
               key.push(parseInt(k.substr(24, 8), 16));
               
               var input = krypto.utils.createBuffer(aesPlain);
               
               // encrypt
               cipher = krypto.aes.startEncrypting(key, aesIvWords);
               now = +new Date();
               cipher.update(input);
               cipher.finish();
               totalEncrypt += (+new Date()) - now;
               
               // decrypt
               var ct = cipher.output;
               cipher = krypto.aes.startDecrypting(key, aesIvWords);
               now = +new Date();
               cipher.update(ct);
               cipher.finish();
               totalDecrypt += (+new Date()) - now;
            }
         }

         console.log('encrypt time: ' + (totalEncrypt / totalTimes) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / totalTimes) + ' ms');
         console.log('krypto aes test complete.');
      };

      var aes_jscrypto = function()
      {
         console.log('testing AES (jscrypto) ...');

         var block = [];
         block.push(0x3243f6a8);
         block.push(0x885a308d);
         block.push(0x313198a2);
         block.push(0xe0370734);
         /*
         block.push(0x00112233);
         block.push(0x44556677);
         block.push(0x8899aabb);
         block.push(0xccddeeff);
         */
         
         var key = [];
         key.push(0x2b7e1516);
         key.push(0x28aed2a6);
         key.push(0xabf71588);
         key.push(0x09cf4f3c);
         /*
         key.push(0x00010203);
         key.push(0x04050607);
         key.push(0x08090a0b);
         key.push(0x0c0d0e0f);
         */
         
         var expect = [];
         expect.push(0x3925841d);
         expect.push(0x02dc09fb);
         expect.push(0xdc118597);
         expect.push(0x196a0b32);
         /*
         expect.push(0x69c4e0d8);
         expect.push(0x6a7b0430);
         expect.push(0xd8cdb780);
         expect.push(0x70b4c55a);
         */
         
         var cipher = new aes(key);
         var ct = [];
         cipher.encryptBlock(block, ct, false);
         
         console.log('ct', ct);
         console.log('expect', expect);

         var dt = [];
         cipher.decryptBlock(ct, dt);

         console.log('dt', dt);
         console.log('expect', block);

         /*
         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         for(var i = 0; i < aesKeys.length; i++)
         {
            var key = aesKeys[i];
            var cipher = new aes(key, OCB);
            var ciphered = [];
            var plain = [];
            var macTag = [];

            // encrypt
            now = +new Date();
            cipher.encrypt(aesIv, aesPlain, ciphered, '', macTag);
            totalEncrypt += (+new Date()) - now;
            console.log('ciphered', aes._hex(ciphered));
            
            // decrypt
            now = +new Date();
            cipher.decrypt(ciphered, plain, macTag);
            totalDecrypt += (+new Date()) - now;

            console.log('plain', plain);
         }

         var len = aesKeys.length;
         console.log('encrypt time: ' + (totalEncrypt / len) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / len) + ' ms');
         console.log('jscrypto aes test complete.');
         */
      };

      var aes_pid_crypt = function()
      {
         console.log('testing AES (pidcrypt) ...');

         var now;
         var totalEncrypt = 0;
         var totalDecrypt = 0;
         for(var i = 0; i < aesKeys.length; i++)
         {
            var cipher = new pidCrypt.AES.CBC();
            var key = aesKeys[i];
            var plainBytes = aesPlainBytes;

            // encrypt
            cipher.initByValues('', key, aesIv);
            now = +new Date();
            var cipherBytes = cipher.encryptRaw(plainBytes);
            totalEncrypt += (+new Date()) - now;
            
            // decrypt
            cipher.initByValues('', key, aesIv);
            now = +new Date();
            cipher.decryptRaw(cipherBytes);
            totalDecrypt += (+new Date()) - now;

            /* Base64-encoding used here
            // encrypt
            cipher.initByValues(aesPlain, key, aesIv);
            now = +new Date();
            var ciphered = cipher.encrypt();
            totalEncrypt += (+new Date()) - now;

            // decrypt
            cipher.initByValues(ciphered, key, aesIv);
            now = +new Date();
            cipher.decrypt();
            totalDecrypt += (+new Date()) - now;
            */
         }

         var len = aesKeys.length;
         console.log('encrypt time: ' + (totalEncrypt / len) + ' ms');
         console.log('decrypt time: ' + (totalDecrypt / len) + ' ms');
         console.log('pidcrypt aes test complete.');
      };

      var aes_as3crypto = function()
      {
         console.log('testing AES (as3crypto) ...');
         document.getElementById('flashTest').aes();
      };

      var aes_flash_128 = function()
      {
         console.log('testing AES (flash 128) ...');
         document.getElementById('flashTest').aes_flash_128();
      };

      var aes_flash_test = function()
      {
         console.log('testing AES (flash) ...');
         document.getElementById('flashTest').aes_test();
      };

      </script>
   </head>
   <body>
      <p>Use the controls below to test krypto stuff.</p>
      <div id="random_controls">
         <button id="clear" onclick="javascript:return canvas_clear();">clear</button>
         <button id="random1" onclick="javascript:return random_krypto();">krypto</button>
         <button id="random2" onclick="javascript:return random_pidcrypt();">pidcrypt</button>
      </div>
      <canvas id="canvas" width="300" height="300"></canvas>
      <div id="util_controls">
         <button id="buffer" onclick="javascript:return test_buffer();">buffer</button>
      </div>
      <div id="flashTest">
         <p>Could not load the flash Test.</p>
      </div>
      <div id="aes_controls">
         <button id="aes1" onclick="javascript:return aes_krypto_128();">krypto 128</button>
         <button id="aes2" onclick="javascript:return aes_krypto_192();">krypto 192</button>
         <button id="aes3" onclick="javascript:return aes_krypto_256();">krypto 256</button>
         <br />
         <button id="aes4" onclick="javascript:return aes_krypto();">krypto</button>
         <button id="aes5" onclick="javascript:return aes_krypto_cbc();">krypto CBC</button>
         <button id="aes6" onclick="javascript:return aes_krypto_cbc_speed();">krypto CBC speed</button>
         <button id="aes7" onclick="javascript:return aes_jscrypto();">jscrypto</button>
         <button id="aes8" onclick="javascript:return aes_pid_crypt();">pidcrypt</button>
         <button id="aes9" onclick="javascript:return aes_as3crypto();">as3crypto</button>
         <button id="aes10" onclick="javascript:return aes_flash_128();">flash 128</button>
         <button id="aes11" onclick="javascript:return aes_flash_test();">flash test</button>
      </div>
   </body>
</html>
